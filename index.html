<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Bilingual Trainer ‚Äì Natural Korean Edition</title>
<style>
  body{font-family:Arial,sans-serif;text-align:center;margin:25px;font-size:19.2px;}
  input{margin:4px;padding:6px;font-size:16.8px;}
  button{margin:6px;padding:7px 14px;cursor:pointer;font-size:16.8px;}
  button:disabled{cursor:not-allowed;}
  table{margin:0 auto;border-collapse:collapse;}
  th,td{padding:7px;font-size:16.8px;}
  .quiz,.sentences,.editor{display:none;margin-top:20px;}
  .wordBox{margin-bottom:18px;font-size:19.2px;}
  #savedNotice{font-size:16.8px;color:green;margin-top:10px;}
  .confirmation{
    font-size:16.8px;
    color:white;
    background:#4CAF50;
    padding:10px 20px;
    border-radius:5px;
    margin-top:10px;
    display:inline-block;
    animation:fadeOut 3s forwards;
  }
  @keyframes fadeOut{
    0%{opacity:1;}
    70%{opacity:1;}
    100%{opacity:0;display:none;}
  }
  .hint{font-size:16.8px;color:#666;margin:10px 0;}
  .korean-text{font-size:21.6px;color:#0066cc;}
  button:hover:not(:disabled){background:#f0f0f0;}
  .score{font-size:21.6px;color:#0066cc;margin:15px 0;font-weight:bold;}
  .progress{font-size:16.8px;color:#666;margin:10px 0;}
  .tooltip{
    position:relative;
    cursor:pointer;
    border-bottom:1px dotted #0066cc;
    color:#0066cc;
    transition:all 0.2s;
  }
  .tooltip:hover{
    color:#004499;
    border-bottom-color:#004499;
  }
  .tooltip:active{
    transform:scale(0.98);
  }
  .tooltip:hover::after{
    content:attr(data-tooltip);
    position:absolute;
    bottom:100%;
    left:50%;
    transform:translateX(-50%);
    background:#333;
    color:white;
    padding:6px 10px;
    border-radius:4px;
    white-space:nowrap;
    font-size:0.9em;
    z-index:1000;
    margin-bottom:5px;
  }
  .tooltip:hover::before{
    content:'';
    position:absolute;
    bottom:100%;
    left:50%;
    transform:translateX(-50%);
    border:5px solid transparent;
    border-top-color:#333;
    margin-bottom:-5px;
  }
  .speed-controls{margin:15px 0;padding:10px;background:#f5f5f5;border-radius:5px;}
  .speed-btn{margin:0 5px;padding:8px 16px;border:2px solid #ccc;background:white;border-radius:4px;font-size:15px;}
  .speed-btn.active{background:#0066cc;color:white;border-color:#0066cc;font-weight:bold;}
  .speed-btn:hover{background:#e6f2ff;}
</style>
</head>
<body>
<h2 style="font-size:28.8px;">Korean ‚Üî English Trainer ‚Äì Everyday Polite</h2>

<div id="inputSection">
  <p>Type up to 3 new word pairs, or use Random Review to practice saved words.</p>
  <p class="hint">üí° Start typing to see suggestions from the starter Korean-English vocabulary</p>
  <table>
    <tr><th>English</th><th>Korean</th></tr>
    <tr>
      <td><input id="en1" list="enSuggestions" oninput="debouncedAutoFillKorean(1)" placeholder="English (to go)"></td>
      <td><input id="ko1" list="koSuggestions" oninput="debouncedAutoFillEnglish(1)" class="korean-text" placeholder="Korean (Í∞ÄÎã§)"></td>
    </tr>
    <tr>
      <td><input id="en2" list="enSuggestions" oninput="debouncedAutoFillKorean(2)" placeholder="English (to eat)"></td>
      <td><input id="ko2" list="koSuggestions" oninput="debouncedAutoFillEnglish(2)" class="korean-text" placeholder="Korean (Î®πÎã§)"></td>
    </tr>
    <tr>
      <td><input id="en3" list="enSuggestions" oninput="debouncedAutoFillKorean(3)" placeholder="English (to see)"></td>
      <td><input id="ko3" list="koSuggestions" oninput="debouncedAutoFillEnglish(3)" class="korean-text" placeholder="Korean (Î≥¥Îã§)"></td>
    </tr>
  </table>
  
  <!-- Datalists for autocomplete -->
  <datalist id="enSuggestions"></datalist>
  <datalist id="koSuggestions"></datalist>
  
  <div style="margin:15px 0;">
    <label><input type="radio" name="mode" value="enko" checked> English ‚Üí Korean</label>
    <label><input type="radio" name="mode" value="koen"> Korean ‚Üí English</label>
  </div>
  
  <button onclick="startQuiz()">Start Quiz (New Words)</button>
  <button id="randomBtn" onclick="startRandom()">üå± Random Review</button><br>
  <button onclick="showEditor()">üìñ View/Edit My Words</button>
  <button onclick="exportWords()">üíæ Export Words</button>
  <button onclick="document.getElementById('importFile').click()">üì• Import Words</button>
  <input type="file" id="importFile" accept=".json" style="display:none;" onchange="importWords(event)">
  <button onclick="clearSaved()">üóë Clear All Words</button>
  <div id="savedNotice"></div>
  <p id="randomDisabledMsg" class="hint" style="display:none;color:#888;font-size:14.4px;">Add at least 1 word pair to unlock Random Review.</p>
</div>

<div class="quiz" id="quizSection">
  <h3 style="font-size:24px;">Match the meanings</h3>
  <div class="progress" id="quizProgress">Answered: 0/0</div>
  <div id="quizContent"></div>
  <button id="nextBtn" onclick="showSentences()" disabled>Next: Use in Sentences</button>
  <div class="score" id="scoreDisplay"></div>
</div>

<div class="sentences" id="sentenceSection">
  <h3 style="font-size:24px;">Simple Sentences (Everyday Polite)</h3>
  <div id="sentences"></div>
  <button onclick="restart()">Start Over</button>
</div>

<div class="editor" id="editorSection">
  <h3 style="font-size:24px;">My Saved Words</h3>
  <p class="hint">Total saved words: <span id="wordCount">0</span></p>
  <p class="hint" style="font-size:14.4px;color:#888;">Saved words are used for Random Review and tracking your progress.</p>
  <div style="margin:15px 0;">
    <button onclick="exportWords()">üíæ Export Words</button>
    <button onclick="document.getElementById('importFile').click()">üì• Import Words</button>
  </div>
  <table id="editTable" border="1" style="margin:20px auto;">
    <tr><th>English</th><th>Korean</th><th>Actions</th></tr>
  </table>
  <button onclick="returnToMain()">‚Üê Back</button>
</div>

<script>
// --- Built-in mini dictionary for auto-fill (Pack A: Everyday actions) ---
const miniDict = {
  "eat": "Î®πÎã§",
  "drink": "ÎßàÏãúÎã§",
  "go": "Í∞ÄÎã§",
  "come": "Ïò§Îã§",
  "see": "Î≥¥Îã§",
  "watch": "Î≥¥Îã§",
  "read": "ÏùΩÎã§",
  "write": "Ïì∞Îã§",
  "play": "ÎÜÄÎã§",
  "study": "Í≥µÎ∂ÄÌïòÎã§",
  "work": "ÏùºÌïòÎã§",
  "sleep": "ÏûêÎã§",
  "wake up": "ÏùºÏñ¥ÎÇòÎã§",
  "sit": "ÏïâÎã§",
  "stand": "ÏÑúÎã§",
  "talk": "ÎßêÌïòÎã§",
  "speak": "ÎßêÌïòÎã§",
  "listen": "Îì£Îã§",
  "walk": "Í±∑Îã§",
  "run": "Îã¨Î¶¨Îã§"
};

// Create reverse lookup (Korean to English)
const miniDictReverse = {};
Object.entries(miniDict).forEach(([en, ko]) => {
  if (!miniDictReverse[ko]) miniDictReverse[ko] = [];
  miniDictReverse[ko].push(en);
});

// Better sentence patterns for VERBS (verb stem form for Korean)
const verbSentences = {
  "Î®πÎã§": {en: "I want to eat now.", ko: "ÏßÄÍ∏à Î®πÍ≥† Ïã∂Ïñ¥Ïöî."},
  "ÎßàÏãúÎã§": {en: "Let's drink some water.", ko: "Î¨º Ï¢Ä ÎßàÏÖîÏöî."},
  "Í∞ÄÎã§": {en: "Where do you want to go?", ko: "Ïñ¥Îîî Í∞ÄÍ≥† Ïã∂Ïñ¥Ïöî?"},
  "Ïò§Îã§": {en: "Please come here.", ko: "Ïó¨Í∏∞ Ïò§ÏÑ∏Ïöî."},
  "Î≥¥Îã§": {en: "I want to see that.", ko: "Í∑∏Í±∞ Î≥¥Í≥† Ïã∂Ïñ¥Ïöî."},
  "ÏùΩÎã§": {en: "Can you read this?", ko: "Ïù¥Í±∞Î•º ÏùΩÏùÑ Ïàò ÏûàÏñ¥Ïöî?"},
  "Ïì∞Îã§": {en: "I need to write a letter.", ko: "Ìé∏ÏßÄ Ïç®Ïïº Ìï¥Ïöî."},
  "ÎÜÄÎã§": {en: "Let's play together.", ko: "Í∞ôÏù¥ ÎÜÄÏïÑÏöî."},
  "Í≥µÎ∂ÄÌïòÎã§": {en: "I want to study.", ko: "Í≥µÎ∂ÄÌïòÍ≥† Ïã∂Ïñ¥Ïöî."},
  "ÏùºÌïòÎã§": {en: "I'm working now.", ko: "ÏßÄÍ∏à ÏùºÌï¥Ïöî."},
  "ÏûêÎã§": {en: "I want to sleep.", ko: "ÏûêÍ≥† Ïã∂Ïñ¥Ïöî."},
  "ÏùºÏñ¥ÎÇòÎã§": {en: "What time do you wake up?", ko: "Î™á ÏãúÏóê ÏùºÏñ¥ÎÇòÏöî?"},
  "ÏïâÎã§": {en: "Please sit down.", ko: "ÏïâÏúºÏÑ∏Ïöî."},
  "ÏÑúÎã§": {en: "Please stand up.", ko: "ÏÑúÏÑ∏Ïöî."},
  "ÎßêÌïòÎã§": {en: "Can you speak Korean?", ko: "ÌïúÍµ≠Ïñ¥ Ìï† Ïàò ÏûàÏñ¥Ïöî?"},
  "Îì£Îã§": {en: "I'm listening.", ko: "Îì£Í≥† ÏûàÏñ¥Ïöî."},
  "Í±∑Îã§": {en: "Let's walk together.", ko: "Í∞ôÏù¥ Í±∏Ïñ¥Ïöî."},
  "Îã¨Î¶¨Îã§": {en: "I want to run.", ko: "Îã¨Î¶¨Í≥† Ïã∂Ïñ¥Ïöî."}
};

// Word-by-word translation dictionary for hover tooltips
// COMPREHENSIVE - Every word in all 18 sentences covered
const wordDict = {
  // ===== KOREAN TO ENGLISH =====
  
  // Core vocabulary - EVERY noun and standalone word
  "ÏßÄÍ∏à": "now / right now",
  "Ïò§Îäò": "today",
  "Î¨º": "water",
  "Ïó¨Í∏∞": "here",
  "Í∑∏Í±∞": "that (thing)",
  "Ïù¥Í±∞": "this (thing)",
  "Ïù¥": "this (determiner)",
  "Ìé∏ÏßÄ": "letter",
  "Í∞ôÏù¥": "together",
  "Ïñ¥Îîî": "where",
  "Î™á": "what / how many",
  "ÏãúÏóê": "at (time) o'clock",
  "ÌïúÍµ≠Ïñ¥": "Korean language",
  "Îã¨Î¶¨Í∏∞": "running / to run (noun form)",
  "Ï¢Ä": "a little / some / please",
  "Ïàò": "ability / possibility (can)",
  
  // Base verb forms (dictionary form) - for when users enter custom words
  "Î®πÎã§": "to eat (dictionary form)",
  "ÎßàÏãúÎã§": "to drink (dictionary form)",
  "Í∞ÄÎã§": "to go (dictionary form)",
  "Ïò§Îã§": "to come (dictionary form)",
  "Î≥¥Îã§": "to see / to watch (dictionary form)",
  "ÏùΩÎã§": "to read (dictionary form)",
  "Ïì∞Îã§": "to write (dictionary form)",
  "ÎÜÄÎã§": "to play (dictionary form)",
  "Í≥µÎ∂ÄÌïòÎã§": "to study (dictionary form)",
  "ÏùºÌïòÎã§": "to work (dictionary form)",
  "ÏûêÎã§": "to sleep (dictionary form)",
  "ÏùºÏñ¥ÎÇòÎã§": "to wake up (dictionary form)",
  "ÏïâÎã§": "to sit (dictionary form)",
  "ÏÑúÎã§": "to stand (dictionary form)",
  "ÎßêÌïòÎã§": "to talk / to speak (dictionary form)",
  "Îì£Îã§": "to listen (dictionary form)",
  "Í±∑Îã§": "to walk (dictionary form)",
  "Îã¨Î¶¨Îã§": "to run (dictionary form)",
  
  // Words from generic sentence patterns
  "ÎßåÎì§Ïñ¥Ïöî": "make + Ïöî (polite)",
  "ÌïÑÏöîÌï¥Ïöî": "need + Ïöî (polite)",
  "Ï∞æÏùÑ": "find + ÏùÑ (can/future)",
  "ÏàòÏóÖÏóêÏÑú": "in class (ÏàòÏóÖ = class, ÏóêÏÑú = in/at)",
  "ÏÇ¨Ïö©Ìï¥Ïöî": "use + Ïöî (polite)",
  
  // Verb stems + grammar particles - KEY FOR UNDERSTANDING KOREAN!
  // Every conjugated verb form that appears in our sentences
  "Î®πÍ≥†": "eat + Í≥† (and/then)",
  "ÎßàÏÖîÏöî": "drink + Ïöî (polite)",
  "Í∞ÄÍ≥†": "go + Í≥† (and/then)",
  "Ïò§ÏÑ∏Ïöî": "come + ÏÑ∏Ïöî (polite command)",
  "Î≥¥Í≥†": "see + Í≥† (and/then)",
  "ÏùΩÏùÑ": "read + ÏùÑ (future/ability form)",
  "Ïç®Ïïº": "write + Ïïº (must)",
  "ÎÜÄÏïÑÏöî": "play + Ïöî (polite)",
  "Í≥µÎ∂ÄÌï¥Ïïº": "study + Ìï¥Ïïº (must do)",
  "ÏùºÌï¥Ïöî": "work + Ïöî (polite)",
  "ÏûêÍ≥†": "sleep + Í≥† (and/then)",
  "ÏùºÏñ¥ÎÇòÏöî": "wake up + Ïöî (polite)",
  "ÏïâÏúºÏÑ∏Ïöî": "sit + ÏúºÏÑ∏Ïöî (polite command)",
  "ÏÑúÏÑ∏Ïöî": "stand + ÏÑ∏Ïöî (polite command)",
  "Ìï†": "do/speak + „Ñπ (can form)",
  "Îì£Í≥†": "listen + Í≥† (and/then)",
  "Í±∏Ïñ¥Ïöî": "walk + Ïöî (polite)",
  
  // Grammar endings & particles - THE GLUE OF KOREAN
  "Ïã∂Ïñ¥Ïöî": "want to (verb-Í≥† Ïã∂Ïñ¥Ïöî = want to verb)",
  "ÏûàÏñ¥Ïöî": "exist / have / can / is/am/are",
  "Ìï¥Ïöî": "do + Ïöî (polite ending)",
  "Ï¢ãÏïÑÌï¥Ïöî": "like + Ïöî (polite)",
  
  // ===== ENGLISH TO KOREAN =====
  
  // Pronouns & basic words
  "I": "Ï†Ä (formal) / ÎÇò (casual)",
  "I'm": "ÎÇòÎäî / Ï†ÄÎäî (I + topic marker)",
  "Im": "ÎÇòÎäî / Ï†ÄÎäî (I + topic marker)",
  "We": "Ïö∞Î¶¨ (we)",
  "We're": "Ïö∞Î¶¨Îäî (we + topic marker)",
  "Were": "Ïö∞Î¶¨Îäî (we + topic marker)",
  "you": "ÎÑà (casual) / ÎãπÏã† (formal)",
  "a": "(no article in Korean)",
  "to": "~Ïóê / ~Î°ú (direction/purpose)",
  "in": "~Ïóê / ~ÏóêÏÑú (in/at)",
  
  // Common verbs (dictionary form)
  "want": "ÏõêÌïòÎã§ / Ïã∂Îã§ (want)",
  "eat": "Î®πÎã§",
  "drink": "ÎßàÏãúÎã§",
  "go": "Í∞ÄÎã§",
  "come": "Ïò§Îã§",
  "see": "Î≥¥Îã§",
  "read": "ÏùΩÎã§",
  "write": "Ïì∞Îã§",
  "play": "ÎÜÄÎã§",
  "study": "Í≥µÎ∂ÄÌïòÎã§",
  "work": "ÏùºÌïòÎã§",
  "sleep": "ÏûêÎã§",
  "wake": "ÏùºÏñ¥ÎÇòÎã§",
  "sit": "ÏïâÎã§",
  "stand": "ÏÑúÎã§",
  "speak": "ÎßêÌïòÎã§",
  "listen": "Îì£Îã§",
  "walk": "Í±∑Îã§",
  "run": "Îã¨Î¶¨Îã§",
  "like": "Ï¢ãÏïÑÌïòÎã§",
  
  // Question words
  "Where": "Ïñ¥Îîî",
  "What": "Î¨¥Ïóá / Î≠ê",
  "Can": "~Ìï† Ïàò ÏûàÎã§ (can/able to)",
  
  // Common verbs (dictionary form)
  "want": "ÏõêÌïòÎã§ / Ïã∂Îã§ (want)",
  "eat": "Î®πÎã§",
  "drink": "ÎßàÏãúÎã§",
  "go": "Í∞ÄÎã§",
  "come": "Ïò§Îã§",
  "see": "Î≥¥Îã§",
  "read": "ÏùΩÎã§",
  "write": "Ïì∞Îã§",
  "play": "ÎÜÄÎã§",
  "study": "Í≥µÎ∂ÄÌïòÎã§",
  "work": "ÏùºÌïòÎã§",
  "sleep": "ÏûêÎã§",
  "wake": "ÏùºÏñ¥ÎÇòÎã§",
  "sit": "ÏïâÎã§",
  "stand": "ÏÑúÎã§",
  "speak": "ÎßêÌïòÎã§",
  "listen": "Îì£Îã§",
  "walk": "Í±∑Îã§",
  "run": "Îã¨Î¶¨Îã§",
  "like": "Ï¢ãÏïÑÌïòÎã§",
  "find": "Ï∞æÎã§ (to find)",
  "make": "ÎßåÎì§Îã§ (to make)",
  "use": "ÏÇ¨Ïö©ÌïòÎã§ (to use)",
  
  // Articles & modifiers
  "the": "(no article in Korean)",
  "now": "ÏßÄÍ∏à",
  "today": "Ïò§Îäò",
  "here": "Ïó¨Í∏∞",
  "that": "Í∑∏Í±∞ (that thing)",
  "this": "Ïù¥Í±∞ (this thing)",
  "some": "Ï¢Ä / Ïñ¥Îñ§",
  "together": "Í∞ôÏù¥",
  
  // Nouns
  "water": "Î¨º",
  "letter": "Ìé∏ÏßÄ",
  "time": "ÏãúÍ∞Ñ / Îïå",
  "Korean": "ÌïúÍµ≠Ïñ¥ (Korean language)",
  "running": "Îã¨Î¶¨Í∏∞",
  "class": "ÏàòÏóÖ (class/lesson)",
  
  // Politeness markers & commands
  "Please": "Ï†úÎ∞ú / ~ÏÑ∏Ïöî (polite request)",
  "Let's": "~Ïûê / ~Ïöî (suggestion)",
  "Lets": "~Ïûê / ~Ïöî (suggestion)",
  
  // Grammar constructions
  "do": "ÌïòÎã§",
  "have": "ÏûàÎã§ / Í∞ÄÏßÄÎã§",
  "need": "ÌïÑÏöîÌïòÎã§ / ~Ìï¥Ïïº ÌïòÎã§ (must)",
  "working": "ÏùºÌïòÎäî Ï§ë (progressive)",
  "using": "ÏÇ¨Ïö©ÌïòÎäî Ï§ë (progressive)",
  "listening": "Îì£Îäî Ï§ë (progressive)",
  
  // Directional words
  "up": "ÏúÑ / Ïò¨Îùº",
  "down": "ÏïÑÎûò / ÎÇ¥Î†§"
};

// =======================================================
let dict = {}, 
    saved = {},
    sentences = {},
    quizAnswers = {},
    totalQuestions = 0,
    correctAnswers = 0,
    speechRate = 0.7; // Default to medium-slow speed for learning

// Debounce utility for smooth autocomplete
function debounce(func, delay) {
  let timeoutId;
  return function(...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => func.apply(this, args), delay);
  };
}

// Load saved data
function loadData() {
  try {
    const savedData = localStorage.getItem('koenJournal');
    const sentenceData = localStorage.getItem('koenSentences');
    if (savedData) saved = JSON.parse(savedData);
    if (sentenceData) sentences = JSON.parse(sentenceData);
  } catch(e) {
    console.log("No saved data yet");
  }
}

// Migrate old sentence data to fix grammar issues from previous versions
function migrateLegacySentences() {
  let updated = false;
  
  // Fix sentences that are missing "to" with main verbs
  Object.keys(sentences).forEach(key => {
    const sentence = sentences[key];
    if (!sentence || !sentence.en) return;
    
    let newEn = sentence.en;
    
    // FIRST: Fix any double "to to" errors (from buggy migration)
    newEn = newEn.replace(/\bto\s+to\b/gi, 'to');
    
    // Fix "I need [verb]" ‚Üí "I need to [verb]" (but NOT if "to" already there)
    // Uses negative lookahead (?!to ) to skip if "to" follows "need"
    newEn = newEn.replace(/I need (?!to )([a-z]+)/gi, 'I need to $1');
    
    // Fix "I want [verb]" ‚Üí "I want to [verb]"
    newEn = newEn.replace(/I want (?!to )([a-z]+)/gi, 'I want to $1');
    
    // Fix "I like [verb]" ‚Üí "I like to [verb]"
    newEn = newEn.replace(/I like (?!to )([a-z]+)/gi, 'I like to $1');
    
    // If we made changes, update the sentence
    if (newEn !== sentence.en) {
      sentences[key].en = newEn;
      updated = true;
      console.log(`Migrated: "${sentence.en}" ‚Üí "${newEn}"`);
    }
  });
  
  // Save updated sentences back to localStorage
  if (updated) {
    try {
      localStorage.setItem('koenSentences', JSON.stringify(sentences));
      console.log('‚úì Sentence grammar migration completed');
    } catch(e) {
      console.error('Failed to save migrated sentences:', e);
    }
  }
}

// Populate datalists on page load
window.onload = () => {
  loadData();
  migrateLegacySentences(); // Fix any old grammar issues from previous versions
  updateRandomButtonState(); // Check if Random Review should be enabled
  
  if(Object.keys(saved).length) {
    document.getElementById('savedNotice').textContent = `Saved words loaded ‚úì (${Object.keys(saved).length} words)`;
  }
  
  // Populate English suggestions
  const enList = document.getElementById('enSuggestions');
  Object.keys(miniDict).forEach(word => {
    const option = document.createElement('option');
    option.value = word;
    enList.appendChild(option);
  });
  
  // Populate Korean suggestions
  const koList = document.getElementById('koSuggestions');
  Object.values(miniDict).forEach(word => {
    const option = document.createElement('option');
    option.value = word;
    koList.appendChild(option);
  });
  
  // Add Enter key navigation
  setupEnterKeyNavigation();
};

// Auto-fill functions
function autoFillKorean(num) {
  const enInput = document.getElementById(`en${num}`);
  const koInput = document.getElementById(`ko${num}`);
  const enValue = enInput.value.trim().toLowerCase();
  
  if (miniDict[enValue] && !koInput.value) {
    koInput.value = miniDict[enValue];
  }
}

function autoFillEnglish(num) {
  const enInput = document.getElementById(`en${num}`);
  const koInput = document.getElementById(`ko${num}`);
  const koValue = koInput.value.trim();
  
  if (miniDictReverse[koValue] && !enInput.value) {
    enInput.value = miniDictReverse[koValue][0];
  }
}

// Create debounced versions for smoother typing experience
const debouncedAutoFillKorean = debounce(autoFillKorean, 200);
const debouncedAutoFillEnglish = debounce(autoFillEnglish, 200);

// Update Random Review button state based on saved words
function updateRandomButtonState() {
  const randomBtn = document.getElementById('randomBtn');
  const randomMsg = document.getElementById('randomDisabledMsg');
  const hasSavedWords = Object.keys(saved).length > 0;
  
  randomBtn.disabled = !hasSavedWords;
  randomMsg.style.display = hasSavedWords ? 'none' : 'block';
}

// Setup Enter key navigation between fields
function setupEnterKeyNavigation() {
  const fields = ['en1', 'ko1', 'en2', 'ko2', 'en3', 'ko3'];
  fields.forEach((fieldId, index) => {
    document.getElementById(fieldId).addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        if (index < fields.length - 1) {
          // Move to next field
          document.getElementById(fields[index + 1]).focus();
        } else {
          // On last field, trigger Start Quiz
          startQuiz();
        }
      }
    });
  });
}

// Show animated confirmation message
function showConfirmation(message) {
  const notice = document.getElementById('savedNotice');
  // Replace newlines with <br> tags for HTML display
  const htmlMessage = message.replace(/\n/g, '<br>');
  notice.innerHTML = `<span class="confirmation">${htmlMessage}</span>`;
  setTimeout(() => {
    notice.innerHTML = `Saved words: ${Object.keys(saved).length}`;
  }, 3000);
}

function speak(t, l) {
  const u = new SpeechSynthesisUtterance(t);
  u.lang = l;
  u.rate = speechRate; // Use global speech rate setting
  speechSynthesis.speak(u);
}

// Set speech rate and update button styles
function setSpeechRate(rate) {
  speechRate = rate;
  // Update button styles
  document.querySelectorAll('.speed-btn').forEach(btn => {
    btn.classList.remove('active');
  });
  event.target.classList.add('active');
}

// Add hover tooltips to words for vocabulary building
function addTooltips(sentence, isKorean) {
  // Split on spaces AND punctuation while capturing them as separate tokens
  const words = sentence.split(/(\s+|[.,!?;:'"()[\]{}])/);
  const lang = isKorean ? 'ko-KR' : 'en-US';
  
  return words.map(word => {
    // Remove ALL punctuation for lookup (more comprehensive)
    const cleanWord = word.replace(/[.,!?;:'"()[\]{}]/g, '').trim();
    
    // Skip empty words
    if (!cleanWord) return word;
    
    const translation = wordDict[cleanWord];
    if (translation) {
      // Make word clickable to speak it (escape quotes for onclick)
      const escapedWord = cleanWord.replace(/'/g, "\\'");
      return `<span class="tooltip" data-tooltip="${translation}" onclick="speak('${escapedWord}', '${lang}')">${word}</span>`;
    }
    // If no translation found, return word unchanged (no tooltip)
    return word;
  }).join('');
}

// Clear input fields
function clearInputs() {
  for(let i = 1; i <= 3; i++) {
    document.getElementById(`en${i}`).value = '';
    document.getElementById(`ko${i}`).value = '';
  }
}

// Normalize Korean verbs to dictionary form (ending in Îã§)
function normalizeVerb(korean, english) {
  // Check if this looks like a verb based on English word
  const isVerbInDict = miniDict[english.toLowerCase()] !== undefined;
  
  // If it ends in Îã§, it's already in dictionary form
  if (korean.endsWith('Îã§')) {
    return { normalized: korean, wasNormalized: false };
  }
  
  // If this is a known verb and doesn't end in Îã§, it might be conjugated
  if (isVerbInDict) {
    // Common polite endings: Ïñ¥Ïöî, ÏïÑÏöî, Ìï¥Ïöî, etc.
    // Try to find the stem and add Îã§
    let stem = korean;
    
    // Remove common polite endings
    if (korean.endsWith('Ïñ¥Ïöî') || korean.endsWith('ÏïÑÏöî')) {
      stem = korean.slice(0, -2); // Remove Ïñ¥Ïöî/ÏïÑÏöî
    } else if (korean.endsWith('Ìï¥Ïöî')) {
      stem = korean.slice(0, -2); // Remove Ìï¥Ïöî
    } else if (korean.endsWith('ÏÑ∏Ïöî')) {
      stem = korean.slice(0, -2); // Remove ÏÑ∏Ïöî
    } else if (korean.endsWith('Í≥†')) {
      stem = korean.slice(0, -1); // Remove Í≥†
    }
    
    // If we found a stem, suggest dictionary form
    if (stem !== korean) {
      return { normalized: stem + 'Îã§', wasNormalized: true, original: korean };
    }
  }
  
  // Not a verb or already correct
  return { normalized: korean, wasNormalized: false };
}

// ---- NEW WORD QUIZ ----
function startQuiz() {
  dict = {};
  const ens = [en1.value.trim(), en2.value.trim(), en3.value.trim()].filter(Boolean);
  const kos = [ko1.value.trim(), ko2.value.trim(), ko3.value.trim()].filter(Boolean);
  
  let newWordsCount = 0;
  let duplicatesCount = 0;
  let normalizedWords = [];
  
  for(let i = 0; i < ens.length; i++) {
    if(ens[i] && kos[i]) {
      // Normalize Korean verbs to dictionary form
      const normResult = normalizeVerb(kos[i], ens[i]);
      const normalizedKorean = normResult.normalized;
      
      // Track if normalization occurred
      if (normResult.wasNormalized) {
        normalizedWords.push({ original: normResult.original, normalized: normalizedKorean });
        // Update the Korean array with normalized form
        kos[i] = normalizedKorean;
      }
      
      dict[ens[i]] = normalizedKorean;
      
      // Check if it's a new word or duplicate
      if(saved[ens[i]]) {
        duplicatesCount++;
      } else {
        newWordsCount++;
      }
      
      saved[ens[i]] = normalizedKorean;
      
      // Use pre-made sentences if available, otherwise create generic ones
      if(!sentences[ens[i]]) {
        if(verbSentences[normalizedKorean]) {
          sentences[ens[i]] = verbSentences[normalizedKorean];
        } else {
          sentences[ens[i]] = {
            en: `I want to ${ens[i]}.`,
            ko: `${normalizedKorean}Í≥† Ïã∂Ïñ¥Ïöî.`
          };
        }
      }
    }
  }
  
  if(Object.keys(dict).length === 0) {
    alert("Please enter at least one word pair.");
    return;
  }
  
  localStorage.setItem('koenJournal', JSON.stringify(saved));
  localStorage.setItem('koenSentences', JSON.stringify(sentences));
  
  // Show confirmation message
  let confirmMsg = '';
  if(duplicatesCount > 0 && newWordsCount === 0) {
    confirmMsg = `Already saved. You can review with Random Review.`;
  } else if(newWordsCount > 0) {
    confirmMsg = `Saved ${newWordsCount} new word pair${newWordsCount > 1 ? 's' : ''}!`;
  }
  
  // Add normalization notice if any verbs were normalized
  if (normalizedWords.length > 0) {
    const normalizedList = normalizedWords.map(w => `${w.original} ‚Üí ${w.normalized}`).join(', ');
    confirmMsg += `\nüìù Normalized to dictionary form: ${normalizedList}`;
  }
  
  if (confirmMsg) {
    showConfirmation(confirmMsg);
  }
  
  updateRandomButtonState(); // Update button state after saving
  clearInputs(); // Clear the input fields
  document.getElementById("inputSection").style.display = "none";
  buildQuiz();
}

// ---- RANDOM REVIEW ----
function startRandom() {
  if(Object.keys(saved).length === 0) {
    alert("No saved words yet ‚Äî please add some first!");
    return;
  }
  
  const entries = Object.entries(saved);
  dict = {};
  const sample = entries.sort(() => 0.5 - Math.random()).slice(0, 3);
  for(const [en, ko] of sample) {
    dict[en] = ko;
  }
  
  clearInputs(); // Clear the input fields
  document.getElementById("inputSection").style.display = "none";
  buildQuiz();
}

// ---- BUILD QUIZ ----
function buildQuiz() {
  const quizDiv = document.getElementById("quizSection");
  const content = document.getElementById("quizContent");
  content.innerHTML = "";
  
  quizAnswers = {};
  correctAnswers = 0;
  totalQuestions = Object.keys(dict).length;
  
  updateProgress();
  
  const mode = document.querySelector('input[name=mode]:checked').value;
  
  for(const [en, ko] of Object.entries(dict)) {
    const qWord = mode === "enko" ? en : ko;
    const correct = mode === "enko" ? ko : en;
    
    const allChoices = mode === "enko" ? Object.values(saved) : Object.keys(saved);
    const opts = allChoices.filter(x => x !== correct).sort(() => 0.5 - Math.random()).slice(0, 2);
    opts.push(correct);
    const shuffled = opts.sort(() => 0.5 - Math.random());
    
    const div = document.createElement("div");
    div.className = "wordBox";
    div.id = `question-${en}`;
    div.innerHTML = `<b style="font-size:1.2em;">${qWord}</b><br><br>` +
      shuffled.map(o => `<button onclick="check('${o.replace(/'/g, "\\'")}','${correct.replace(/'/g, "\\'")}','${en.replace(/'/g, "\\'")}',this)">${o}</button>`).join(" ");
    content.appendChild(div);
  }
  
  document.getElementById('scoreDisplay').textContent = '';
  quizDiv.style.display = "block";
}

function check(ans, correct, questionKey, btn) {
  if(quizAnswers[questionKey]) return; // Already answered
  
  const isCorrect = ans === correct;
  btn.style.background = isCorrect ? "lightgreen" : "pink";
  
  // Disable all buttons in this question
  const questionDiv = document.getElementById(`question-${questionKey}`);
  const buttons = questionDiv.getElementsByTagName('button');
  for(let b of buttons) {
    b.disabled = true;
    if(b.textContent === correct) {
      b.style.background = "lightgreen";
    }
  }
  
  quizAnswers[questionKey] = isCorrect;
  if(isCorrect) correctAnswers++;
  
  updateProgress();
  checkQuizComplete();
}

function updateProgress() {
  const answered = Object.keys(quizAnswers).length;
  document.getElementById('quizProgress').textContent = `Answered: ${answered}/${totalQuestions}`;
}

function checkQuizComplete() {
  if(Object.keys(quizAnswers).length === totalQuestions) {
    const percentage = Math.round((correctAnswers / totalQuestions) * 100);
    document.getElementById('scoreDisplay').textContent = 
      `Score: ${correctAnswers}/${totalQuestions} (${percentage}%)`;
    document.getElementById('nextBtn').disabled = false;
  }
}

// ---- SHOW SENTENCES ----
function showSentences() {
  document.getElementById("quizSection").style.display = "none";
  const sDiv = document.getElementById("sentenceSection");
  const cont = document.getElementById("sentences");
  cont.innerHTML = "";
  
  cont.innerHTML += `<p class="hint">üí° Hover over <span style="border-bottom:1px dotted #0066cc;color:#0066cc;cursor:help;">blue underlined words</span> to see their translation</p>`;
  
  cont.innerHTML += `<div class="speed-controls">
    <span style="font-weight:bold;margin-right:10px;">üîä Speech Speed:</span>
    <button class="speed-btn" onclick="setSpeechRate(0.6)">üê¢ Slow (0.6x)</button>
    <button class="speed-btn active" onclick="setSpeechRate(0.7)">üìñ Normal (0.7x)</button>
    <button class="speed-btn" onclick="setSpeechRate(1.0)">‚ö° Fast (1.0x)</button>
  </div>`;
  
  for(const [en, ko] of Object.entries(dict)) {
    const pair = sentences[en];
    const eng = pair ? pair.en : `I want to ${en}.`;
    const kor = pair ? pair.ko : `${ko}Í≥† Ïã∂Ïñ¥Ïöî.`;
    
    // Add tooltips to both English and Korean sentences
    const engWithTooltips = addTooltips(eng, false);
    const korWithTooltips = addTooltips(kor, true);
    
    cont.innerHTML += `<div style="margin:20px auto; padding:18px; border:1px solid #ddd; max-width:600px;">
      <p style="font-size:21.6px;">${engWithTooltips}</p>
      <p style="font-size:26.4px; color:#0066cc;">${korWithTooltips}</p>
      <button onclick="speak('${eng.replace(/'/g, "\\'")}','en-US')">üîä English</button>
      <button onclick="speak('${kor.replace(/'/g, "\\'")}','ko-KR')">üîä Korean</button>
      </div>`;
  }
  
  sDiv.style.display = "block";
}

// ---- JOURNAL EDITOR ----
function showEditor() {
  document.getElementById("inputSection").style.display = "none";
  const eDiv = document.getElementById("editorSection");
  const table = document.getElementById("editTable");
  const wordCount = document.getElementById("wordCount");
  
  table.innerHTML = "<tr><th>English</th><th>Korean</th><th>Actions</th></tr>";
  
  const entries = Object.entries(saved).sort((a, b) => a[0].localeCompare(b[0]));
  
  if(entries.length === 0) {
    const r = table.insertRow();
    r.innerHTML = `<td colspan="3" style="text-align:center;color:#666;padding:20px;">No saved words yet. Add some to get started!</td>`;
  } else {
    entries.forEach(([en, ko]) => {
      const r = table.insertRow();
      r.innerHTML = `<td><input value="${en}" onchange="editKey('${en.replace(/'/g, "\\'")}',this.value)"></td>
                     <td><input value="${ko}" onchange="editValue('${en.replace(/'/g, "\\'")}',this.value)" class="korean-text"></td>
                     <td><button onclick="deleteRow('${en.replace(/'/g, "\\'")}')" title="Delete this word">üóë</button></td>`;
    });
  }
  
  wordCount.textContent = entries.length;
  eDiv.style.display = "block";
}

function editKey(oldKey, newKey) {
  if(!newKey || newKey === oldKey) return;
  const v = saved[oldKey];
  const s = sentences[oldKey];
  delete saved[oldKey];
  delete sentences[oldKey];
  saved[newKey] = v;
  if(s) sentences[newKey] = s;
  localStorage.setItem('koenJournal', JSON.stringify(saved));
  localStorage.setItem('koenSentences', JSON.stringify(sentences));
  showEditor();
}

function editValue(k, newVal) {
  saved[k] = newVal;
  localStorage.setItem('koenJournal', JSON.stringify(saved));
}

function deleteRow(k) {
  if(!confirm(`Delete "${k}"?`)) return;
  delete saved[k];
  delete sentences[k];
  localStorage.setItem('koenJournal', JSON.stringify(saved));
  localStorage.setItem('koenSentences', JSON.stringify(sentences));
  updateRandomButtonState(); // Update button state after deleting
  showEditor();
}

function returnToMain() {
  document.getElementById('editorSection').style.display = "none";
  document.getElementById('inputSection').style.display = "block";
  updateRandomButtonState(); // Update button state when returning to main
  if(Object.keys(saved).length) {
    document.getElementById('savedNotice').textContent = `Saved words loaded ‚úì (${Object.keys(saved).length} words)`;
  }
}

function restart() {
  location.reload();
}

function clearSaved() {
  if(!confirm("Clear ALL saved words? This cannot be undone!")) return;
  localStorage.removeItem('koenJournal');
  localStorage.removeItem('koenSentences');
  saved = {};
  sentences = {};
  document.getElementById('savedNotice').textContent = "All words cleared.";
  updateRandomButtonState(); // Update button state after clearing
}

// Export vocabulary to JSON file
function exportWords() {
  if(Object.keys(saved).length === 0) {
    alert("No words to export yet!");
    return;
  }
  
  const data = {
    vocabulary: saved,
    sentences: sentences,
    exportDate: new Date().toISOString(),
    wordCount: Object.keys(saved).length
  };
  
  const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `korean-vocabulary-${Object.keys(saved).length}-words.json`;
  a.click();
  URL.revokeObjectURL(url);
  
  alert(`Exported ${Object.keys(saved).length} words! Share this file with your language partner.`);
}

// Import vocabulary from JSON file
function importWords(event) {
  const file = event.target.files[0];
  if(!file) return;
  
  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const data = JSON.parse(e.target.result);
      
      if(!data.vocabulary) {
        alert("Invalid vocabulary file!");
        return;
      }
      
      // Calculate overlap to warn users about potential overwrites
      let overlapCount = 0;
      Object.keys(data.vocabulary).forEach(key => {
        if (saved[key]) overlapCount++;
      });
      
      // Ask if they want to merge or replace
      let shouldMerge = false;
      if(Object.keys(saved).length > 0) {
        const importMsg = `You have ${Object.keys(saved).length} saved words.\n\n` +
          `Importing ${Object.keys(data.vocabulary).length} words${overlapCount > 0 ? ` (overlapping ${overlapCount})` : ''}.\n\n` +
          `OK = ADD/MERGE (keeps yours, adds new${overlapCount > 0 ? ', overwrites overlaps' : ''}).\n` +
          `Cancel = REPLACE (wipes yours).`;
        shouldMerge = confirm(importMsg);
      }
      
      if(shouldMerge) {
        // Merge: add imported words to existing
        Object.assign(saved, data.vocabulary);
        Object.assign(sentences, data.sentences || {});
      } else {
        // Replace: overwrite with imported
        saved = data.vocabulary;
        sentences = data.sentences || {};
      }
      
      localStorage.setItem('koenJournal', JSON.stringify(saved));
      localStorage.setItem('koenSentences', JSON.stringify(sentences));
      
      updateRandomButtonState(); // Update button state after importing
      
      document.getElementById('savedNotice').textContent = 
        `Imported successfully! You now have ${Object.keys(saved).length} words.`;
      
      alert(`Success! Imported ${Object.keys(data.vocabulary).length} words.`);
      
    } catch(err) {
      alert("Error reading file. Make sure it's a valid vocabulary export.");
      console.error(err);
    }
  };
  reader.readAsText(file);
  
  // Reset file input so same file can be imported again
  event.target.value = '';
}
</script>
</body>
</html>
